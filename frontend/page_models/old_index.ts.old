import { ModelPage } from "./model_page.ts.old";
import { RegionDropdown } from "../components/region-dropdown.ts.old";
import { getTimezone, setGetParamUrl } from "../helpers";
import { Region, Regions } from "../models";
import { makeDataStore } from "../ds";

const SELECTION_PARAM = "selection";
const MITIGATION_PARAM = "mitigation";
const REGION_FALLBACK = "united kingdom";

type Options = {
  region: string | null;
  mitigation: string | null;
};

class Controller {
  modelPage: ModelPage;
  dropdown: RegionDropdown;

  constructor(
    $dropdown: HTMLElement,
    $pageContainer: HTMLElement,
    private regions: Regions,
    params: Options
  ) {
    let mitigation = params.mitigation;

    this.dropdown = new RegionDropdown($dropdown, key => {
      this.changeRegion(key, true);
    });

    // determines the users timezone
    let tz = getTimezone();

    // the region which has our timezone
    let tzRegion: Region | null = null;
    let initialRegion: Region | null = null;
    // populate the dropdown menu with countries from received data
    Object.keys(this.regions).forEach(key => {
      let region = this.regions[key];

      if (!initialRegion) initialRegion = region;

      this.dropdown.addRegionDropdown(
        key,
        this.getRegionUrl(region),
        region.name
      );

      if (tz && region.timezones.indexOf(tz) !== -1) {
        tzRegion = region;
      }
    });

    // default region selection

    // try the fallback
    if (REGION_FALLBACK in this.regions) {
      initialRegion = this.regions[REGION_FALLBACK];
    }

    if (params.region && params.region in this.regions) {
      // prefer a valid region from param (from url)
      initialRegion = this.regions[params.region];
    } else if (tzRegion) {
      // otherwise use the region infered from the timezone
      initialRegion = tzRegion;
    }

    this.dropdown.update(initialRegion!);
    this.modelPage = new ModelPage($pageContainer, {
      mitigation,
      region: initialRegion!
    });

    // initialize the select picker
    $('[data-toggle="tooltip"]').tooltip();
  }

  getRegionUrl(region: Region) {
    return setGetParamUrl(SELECTION_PARAM, region.code);
  }

  // change the displayed region
  changeRegion(regionCode: string, pushState: boolean) {
    let region = this.regions[regionCode];

    if (!region) {
      region = this.regions[REGION_FALLBACK];
      pushState = false;
    }

    // change url
    if (history.pushState && pushState) {
      let path = this.getRegionUrl(region);
      window.history.pushState({ path }, "", path);
    }

    // update the dropdown
    this.dropdown.update(region);

    // update the grap
    if (this.modelPage) {
      this.modelPage.setRegion(region);
    }
  }
}

const $pageContainer = document.getElementById("my_dataviz");
const $dropdown = document.getElementById("regionDropdown");
if ($pageContainer && $dropdown) {
  let urlString = window.location.href;
  let url = new URL(urlString);
  let params = {
    region: url.searchParams.get(SELECTION_PARAM),
    mitigation: url.searchParams.get(MITIGATION_PARAM)
  };

  let data = makeDataStore();

  data.regions.then(regions => {
    new Controller($dropdown, $pageContainer, regions, params);
  });
}
